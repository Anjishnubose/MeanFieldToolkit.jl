var documenterSearchIndex = {"docs":
[{"location":"Build/#MeanFieldToolkit.Build","page":"Build","title":"MeanFieldToolkit.Build","text":"","category":"section"},{"location":"Build/","page":"Build","title":"Build","text":"Modules = [MeanFieldToolkit, MeanFieldToolkit.Build]\nPrivate = false\nPages   = [\"Build.jl\"]\n","category":"page"},{"location":"Build/#MeanFieldToolkit.Build.BuildFromInteractions!-Union{Tuple{R}, Tuple{T}, Tuple{TightBindingMFT{T, R}, Dict{Tuple, Matrix{ComplexF64}}}} where {T, R}","page":"Build","title":"MeanFieldToolkit.Build.BuildFromInteractions!","text":"BuildFromInteractions!(tbMFT::TightBindingMFT{T, R}, HoppingOrderLookup::Dict{Tuple, Matrix{ComplexF64}} ; refresh::Bool = true)\nBuildFromInteractions!(bdgMFT::BdGMFT{T, R, S} , HoppingOrderLookup::Dict{Tuple, Matrix{ComplexF64}}, PairingOrderLookup::Dict{Tuple, Matrix{ComplexF64}} ; refresh::Bool = true)\n\nBuilds the MFT decomposed hoppings (and pairings) given a MFT object and the lookup tables for the expectation values of the different order parameters. If refresh is set to true, then the MFT bonds are deleted and rebuilt from scratch. Otherwise, the new bonds are appended to the existing bonds.\n\n\n\n\n\n","category":"method"},{"location":"TightBindingMFT/#MeanFieldToolkit.TBMFT","page":"TightBindingMFT","title":"MeanFieldToolkit.TBMFT","text":"","category":"section"},{"location":"TightBindingMFT/","page":"TightBindingMFT","title":"TightBindingMFT","text":"Modules = [MeanFieldToolkit, MeanFieldToolkit.TBMFT]\nPrivate = false\nPages   = [\"TightBindingMFT.jl\"]\n","category":"page"},{"location":"TightBindingMFT/#MeanFieldToolkit.TBMFT.TightBindingMFT","page":"TightBindingMFT","title":"MeanFieldToolkit.TBMFT.TightBindingMFT","text":"TightBindingMFT{T, R} is a data type representing a general mean-field simulation on a tight-binding model.\n\nAttributes\n\nmodel              ::  Model: The tight-binding model on which mean-field simulations are going to run, contains info about free hoppings.\nHoppingOrders      ::  Vector{Param{2, R}}: a vector of order parameters to decompose the interactions in during MFT.\nInteractions       ::  Vector{Param{2, FLoat64}}: the vector of Param containing all the information of the interactions acting on the model.\nMFTDecomposition   ::  Vector{Function} : the decomposition function which describes how to take an interaction array + expectation values and give back tight-binding hoppings.\nMFTScaling         ::  Dict{String, Float64}: relative scaling parameters for different mean-field channels.\nChannelLabels      ::  Dict{String, String}: The labels of the different mean-field channels.\n\nInitialize this structure using\n\nTightBindingMFT(model::Model, HoppingOrders::Vector{Param{2, R}}, Interactions::Vector{Param{T, Float64}}, MFTDecomposition::Vector{Function} ; ChannelLabels :: Dict{String, String} = Dict{String, String}(\"ij\" => \"Hopping\", \"ii\" => \"Hopping On-Site\", \"jj\" => \"Hopping On-Site\"))\nTightBindingMFT(model::Model, HoppingOrders::Vector{Param{2, R}}, Interactions::Vector{Param{T, Float64}}, MFTDecomposition::Vector{Function}, MFTScaling::Dict{String, Float64} ; ChannelLabels :: Dict{String, String} = Dict{String, String}(\"ij\" => \"Hopping\", \"ii\" => \"Hopping On-Site\", \"jj\" => \"Hopping On-Site\"))\n\n\n\n\n\n","category":"type"},{"location":"TightBindingMFT/#MeanFieldToolkit.TBMFT.GetMFTEnergy-Union{Tuple{TightBindingMFT{T, R}}, Tuple{R}, Tuple{T}} where {T, R}","page":"TightBindingMFT","title":"MeanFieldToolkit.TBMFT.GetMFTEnergy","text":"GetMFTEnergy(tbMFT::TightBindingMFT{T, R}) --> Float64\n\nReturns the total mean-field energy of the model including decomposed interactions.\n\n\n\n\n\n","category":"method"},{"location":"MFTPlot/#MeanFieldToolkit.MFTPlot","page":"MFTPlot","title":"MeanFieldToolkit.MFTPlot","text":"","category":"section"},{"location":"MFTPlot/","page":"MFTPlot","title":"MFTPlot","text":"Modules = [MeanFieldToolkit, MeanFieldToolkit.MFTPlot]\nPrivate = false\nPages   = [\"MFTPlot.jl\"]\n","category":"page"},{"location":"MFTPlot/#MeanFieldToolkit.MFTPlot.PlotMFT!-Tuple{TightBindingMFT}","page":"MFTPlot","title":"MeanFieldToolkit.MFTPlot.PlotMFT!","text":"PlotMFT!(mft::TightBindingMFT ; plot_labels::Vector{String} = getproperty.(mft.HoppingBlock.params, :label), plot_legend::Bool = true)\nPlotMFT!(mft::BdGMFT ; plot_labels::Vector{String} = getproperty.(mft.HoppingBlock.params, :label), plot_legend::Bool = true)\n\nPlots the order parameters of the given MFT object.\n\nIf plot_labels is passed, then only the order parameters with the given labels are plotted.\nIf plot_legend is passed, then the legend is shown in the plot.\n\n\n\n\n\n","category":"method"},{"location":"MFTPlot/#MeanFieldToolkit.MFTPlot.PlotMFTEnergy!-Tuple{T} where T<:Union{BdGMFT, TightBindingMFT}","page":"MFTPlot","title":"MeanFieldToolkit.MFTPlot.PlotMFTEnergy!","text":"PlotMFTEnergy!(mft::T) where {T<:Union{TightBindingMFT, BdGMFT}}\n\nPlots the mean-field energy of the given MFT object.\n\n\n\n\n\n","category":"method"},{"location":"BdGMFT/#MeanFieldToolkit.BDGMFT","page":"BdGMFT","title":"MeanFieldToolkit.BDGMFT","text":"","category":"section"},{"location":"BdGMFT/","page":"BdGMFT","title":"BdGMFT","text":"Modules = [MeanFieldToolkit, MeanFieldToolkit.BDGMFT]\nPrivate = false\nPages   = [\"BdGMFT.jl\"]\n","category":"page"},{"location":"BdGMFT/#MeanFieldToolkit.BDGMFT.BdGMFT","page":"BdGMFT","title":"MeanFieldToolkit.BDGMFT.BdGMFT","text":"BdGMFT{T, R, S} is a data type representing a general mean-field simulation on a BdG model.\n\nAttributes\n\nmodel              ::  Model: The BdG model on which mean-field simulations are going to run, contains info about free hopping and pairing.\nHoppingOrders      ::  Vector{Param{2, R}}: a vector of hopping order parameters to decompose the interactions in during MFT.\nPairingOrders      ::  Vector{Param{2, R}}: a vector of pairing order parameters to decompose the interactions in during MFT.\nInteractions       ::  Vector{Param{2, FLoat64}}: the vector of Param containing all the information of the interactions acting on the model.\nHoppingDecomposition   ::  Vector{Function} : the decomposition function which describes how to take an interaction array + hopping expectation values and give back tight-binding hoppings.\nHoppingDecomposition   ::  Vector{Function} : the decomposition function which describes how to take an interaction array + pairing expectation values and give back BdG pairings.\nHoppingScaling     ::  Dict{String, Float64}: relative scaling parameters for different hopping mean-field channels.\nPairingScaling     ::  Dict{String, Float64}: relative scaling parameters for different pairing mean-field channels.\nHoppingLabels      ::  Dict{String, String}: The labels of the different hopping mean-field channels.\nPairingLabels      ::  Dict{String, String}: The labels of the different hopping mean-field channels.\n\nInitialize this structure using \n\nBdGMFT(model::BdGModel, HoppingOrders::Vector{Param{2, R}}, PairingOrders::Vector{Param{2, S}}, Interactions::Vector{Param{T, Float64}} , HoppingDecomposition::Vector{Function}, PairingDecomposition::Vector{Function} ; HoppingLabels::Dict{String, String} = Dict{String, String}(\"ij\" => \"Hopping\", \"ii\" => \"Hopping On-Site\", \"jj\" => \"Hopping On-Site\"), PairingLabels::Dict{String, String} = Dict{String, String}(\"ij\" => \"Pairing\", \"ii\" => \"Pairing On-Site\", \"jj\" => \"Pairing On-Site\"))\nBdGMFT(model::BdGModel, HoppingOrders::Vector{Param{2, R}}, PairingOrders::Vector{Param{2, S}}, Interactions::Vector{Param{T, Float64}} , HoppingDecomposition::Vector{Function}, PairingDecomposition::Vector{Function}, HoppingScaling::Dict{String, Float64}, PairingScaling::Dict{String, Float64} ; HoppingLabels::Dict{String, String} = Dict{String, String}(\"ij\" => \"Hopping\", \"ii\" => \"Hopping On-Site\", \"jj\" => \"Hopping On-Site\"), PairingLabels::Dict{String, String} = Dict{String, String}(\"ij\" => \"Pairing\", \"ii\" => \"Pairing On-Site\", \"jj\" => \"Pairing On-Site\"))\nBdGMFT(model::BdGModel, PairingOrders::Vector{Param{2, S}}, Interactions::Vector{Param{T, Float64}} , HoppingDecomposition::Vector{Function}, PairingDecomposition::Vector{Function} ; HoppingLabels::Dict{String, String} = Dict{String, String}(\"ij\" => \"Hopping\", \"ii\" => \"Hopping On-Site\", \"jj\" => \"Hopping On-Site\"), PairingLabels::Dict{String, String} = Dict{String, String}(\"ij\" => \"Pairing\", \"ii\" => \"Pairing On-Site\", \"jj\" => \"Pairing On-Site\"))\nBdGMFT(model::BdGModel, PairingOrders::Vector{Param{2, S}}, Interactions::Vector{Param{T, Float64}} , HoppingDecomposition::Vector{Function}, PairingDecomposition::Vector{Function}, HoppingScaling::Dict{String, Float64}, PairingScaling::Dict{String, Float64} ; HoppingLabels::Dict{String, String} = Dict{String, String}(\"ij\" => \"Hopping\", \"ii\" => \"Hopping On-Site\", \"jj\" => \"Hopping On-Site\"), PairingLabels::Dict{String, String} = Dict{String, String}(\"ij\" => \"Pairing\", \"ii\" => \"Pairing On-Site\", \"jj\" => \"Pairing On-Site\"))\n\n\n\n\n\n","category":"type"},{"location":"BdGMFT/#MeanFieldToolkit.TBMFT.GetMFTEnergy-Union{Tuple{BdGMFT{T, R, S}}, Tuple{S}, Tuple{R}, Tuple{T}} where {T, R, S}","page":"BdGMFT","title":"MeanFieldToolkit.TBMFT.GetMFTEnergy","text":"GetMFTEnergy(bdgMFT::BdGMFT{T, R}) --> Float64\n\nReturns the total mean-field energy of the BdG model including decomposed interactions.\n\n\n\n\n\n","category":"method"},{"location":"MFTDecompose/#MeanFieldToolkit.MFTDecompose","page":"MFTDecompose","title":"MeanFieldToolkit.MFTDecompose","text":"","category":"section"},{"location":"MFTDecompose/","page":"MFTDecompose","title":"MFTDecompose","text":"Modules = [MeanFieldToolkit, MeanFieldToolkit.MFTDecompose]\nPrivate = false\nPages   = [\"MFTDecompose.jl\"]\n","category":"page"},{"location":"MFTDecompose/#MeanFieldToolkit.MFTDecompose.InterQuarticToHopping-Tuple{Array{ComplexF64, 4}, Dict{String, Matrix{ComplexF64}}}","page":"MFTDecompose","title":"MeanFieldToolkit.MFTDecompose.InterQuarticToHopping","text":"InterQuarticToHopping(Uij::Array{ComplexF64, 4}, Chis::Dict{String, Matrix{ComplexF64}}) --> Dict{String, Matrix{ComplexF64}}\n\nFunction to decompose a general density-type, inter-site quartic interaction into MFT hopping channels (both inter-site and on-site). The interaction is provided as a rank-4 array living on the bond. The expectation values as a dictionary of matrices containing the expectation values on the two sites, i and j, and the bond i ↔ j with keys \"ii\", \"jj\", and \"ij\".\n\n\n\n\n\n","category":"method"},{"location":"MFTDecompose/#MeanFieldToolkit.MFTDecompose.InterQuarticToPairing-Tuple{Array{ComplexF64, 4}, Dict{String, Matrix{ComplexF64}}}","page":"MFTDecompose","title":"MeanFieldToolkit.MFTDecompose.InterQuarticToPairing","text":"InterQuarticToPairing(Uij::Array{ComplexF64, 4}, Deltas::Dict{String, Matrix{ComplexF64}}) --> Dict{String, Matrix{ComplexF64}}\n\nFunction to decompose a general density-type, inter-site quartic interaction into MFT pairing channels. The interaction is provided as a rank-4 array living on the bond. The expectation values as a dictionary of matrices containing the expectation values on the two sites, i and j, and the bond i ↔ j with keys \"ii\", \"jj\", and \"ij\".\n\n\n\n\n\n","category":"method"},{"location":"MFTDecompose/#MeanFieldToolkit.MFTDecompose.IntraQuarticToHopping-Tuple{Array{ComplexF64, 4}, Dict{String, Matrix{ComplexF64}}}","page":"MFTDecompose","title":"MeanFieldToolkit.MFTDecompose.IntraQuarticToHopping","text":"IntraQuarticToHopping(Uii::Array{ComplexF64, 4}, Chis::Dict{String, Matrix{ComplexF64}}) --> Dict{String, Matrix{ComplexF64}}\n\nFunction to decompose a general density-type, intra-site quartic interaction into MFT hopping channels. The interaction is provided as a rank-4 array living on the site. The expectation values as a dictionary of matrices containing the expectation values on the site, i with key \"ii\".\n\n\n\n\n\n","category":"method"},{"location":"MFTDecompose/#MeanFieldToolkit.MFTDecompose.IntraQuarticToPairing-Tuple{Array{ComplexF64, 4}, Dict{String, Matrix{ComplexF64}}}","page":"MFTDecompose","title":"MeanFieldToolkit.MFTDecompose.IntraQuarticToPairing","text":"IntraQuarticToHopping(Uii::Array{ComplexF64, 4}, Chis::Dict{String, Matrix{ComplexF64}}) --> Dict{String, Matrix{ComplexF64}}\n\nFunction to decompose a general density-type, intra-site quartic interaction into MFT pairing channels. The interaction is provided as a rank-4 array living on the site. The expectation values as a dictionary of matrices containing the expectation values on the site, i with key \"ii\".\n\n\n\n\n\n","category":"method"},{"location":"MFTDecompose/#How-to-write-custom-mean-field-equations","page":"MFTDecompose","title":"How to write custom mean-field equations","text":"","category":"section"},{"location":"MFTDecompose/","page":"MFTDecompose","title":"MFTDecompose","text":"Suppose you are dealing with a 2n-fermion interation on two sites of the general form U^ij_alpha_1alpha_n  beta_1beta_nf^dagger_i alpha_1f_i alpha_2f^dagger_j beta_n-1f_j beta_n. All the information about the interaction will be stored in the rank = 2n arrays U^ij.  \nFurthermore, you will need the expectation value matrices chi_rr^alphabeta = langle f^dagger_r alphaf_r betarangle, for chi_iichi_jj and chi_ij. Assume this is passed as a dictionary of matrices with the keys being ii jj and ij.\nNow, the function which decomposes the interaction on the bond connecting sites i j can be defined as","category":"page"},{"location":"MFTDecompose/","page":"MFTDecompose","title":"MFTDecompose","text":"    function CustomDecomposition(U::Array{Float64, 2*n}, Expectations::Dict{String, Matrix{ComplexF64}}) :: Dict{String, Matrix{ComplexF64}}\n\n        ##### Write down your mean field equations and find their on-site component t_{ii}, t_{jj}, and inter-site t_{ij}\n\n        return Dict(\"ii\" => t_ii, \"jj\" => t_jj, \"ij\" => t_ij)\n    end","category":"page"},{"location":"MFTResume/#MeanFieldToolkit.MFTResume","page":"MFTResume","title":"MeanFieldToolkit.MFTResume","text":"","category":"section"},{"location":"MFTResume/","page":"MFTResume","title":"MFTResume","text":"Modules = [MeanFieldToolkit, MeanFieldToolkit.MFTResume]\nPrivate = false\nPages   = [\"MFTResume.jl\"]\n","category":"page"},{"location":"MFTResume/#MeanFieldToolkit.MFTResume.ReadMFT-Tuple{String}","page":"MFTResume","title":"MeanFieldToolkit.MFTResume.ReadMFT","text":"ReadMFT(fileName::String) --> Dict{String, Any}\n\nReads a mean-field simulation from a checkpoint file. Returns a dictionary containing the following keys:\n\nConvergence: The norm of the difference between the input and the output at the last iteration.\nExpectations: The expectation values of the order parameters in the last iteration.\nIterations: The number of iterations performed.\nMFT: The mean-field theory object used for the simulation.\n\n\n\n\n\n","category":"method"},{"location":"MFTResume/#MeanFieldToolkit.MFTResume.ResumeMFT!-Tuple{String}","page":"MFTResume","title":"MeanFieldToolkit.MFTResume.ResumeMFT!","text":"ResumeMFT!(fileName::String ; Update::Function = SimpleMixing, max_iter::Int64 = 100, tol::Float64 = 1e-6, checkpoint_interval::Int64 = 50) --> SelfCons \n\nResumes a mean-field simulation from a checkpoint file.\n\nIf Update is passed, then the update function is used to perform the self-consistency update.\nIf max_iter is passed, then the maximum number of iterations is set to max_iter.\nIf tol is passed, then the tolerance for convergence is set to tol.\nIf checkpoint_interval is passed, then the checkpoint interval is set to checkpoint_interval.\n\n\n\n\n\n","category":"method"},{"location":"MFTRun/#MeanFieldToolkit.MFTRun","page":"MFTRun","title":"MeanFieldToolkit.MFTRun","text":"","category":"section"},{"location":"MFTRun/","page":"MFTRun","title":"MFTRun","text":"Modules = [MeanFieldToolkit, MeanFieldToolkit.MFTRun]\nPrivate = false\nPages   = [\"MFTRun.jl\"]\n","category":"page"},{"location":"MFTRun/#MeanFieldToolkit.MFTRun.SolveMFT!-Union{Tuple{TightBindingMFT{T, R}}, Tuple{R}, Tuple{T}} where {T, R}","page":"MFTRun","title":"MeanFieldToolkit.MFTRun.SolveMFT!","text":"SolveMFT!(mft::TightBindingMFT{T, R} ; Update::Function = SimpleMixing, Update_kwargs::Dict{Symbol, Any} = Dict{Symbol, Any}(:alpha => 0.5), max_iter::Int64 = 100, tol::Float64 = 1e-6, Initial_range::Tuple{Float64, Float64} = (-0.5, 0.5)) --> SelfCons\nSolveMFT!(mft::BdGMFT{T, R, R} ; Update::Function = SimpleMixing, Update_kwargs::Dict{Symbol, Any} = Dict{Symbol, Any}(:alpha => 0.5), max_iter::Int64 = 100, tol::Float64 = 1e-6, Initial_range::Tuple{Float64, Float64} = (-0.5, 0.5)) --> SelfCons \nSolveMFT!(mft::TightBindingMFT{T, R}, fileName::String ; Update::Function = SimpleMixing, Update_kwargs::Dict{Symbol, Any} = Dict{Symbol, Any}(:alpha => 0.5), max_iter::Int64 = 100, tol::Float64 = 1e-6, checkpoint_interval::Int64 = 50, Initial_range::Tuple{Float64, Float64} = (-0.5, 0.5)) --> SelfCons \nSolveMFT!(mft::BdGMFT{T, R, R}, fileName::String ; Update::Function = SimpleMixing, Update_kwargs::Dict{Symbol, Any} = Dict{Symbol, Any}(:alpha => 0.5), max_iter::Int64 = 100, tol::Float64 = 1e-6, checkpoint_interval::Int64 = 50, Initial_range::Tuple{Float64, Float64} = (-0.5, 0.5)) --> SelfCons \nSolveMFT!(mft::TightBindingMFT{T, R}, Initial::Vector{R}; Update::Function = SimpleMixing, Update_kwargs::Dict{Symbol, Any} = Dict{Symbol, Any}(:alpha => 0.5), max_iter::Int64 = 100, tol::Float64 = 1e-6) --> SelfCons\nSolveMFT!(mft::BdGMFT{T, R, R}, Initial::Vector{R}; Update::Function = SimpleMixing, Update_kwargs::Dict{Symbol, Any} = Dict{Symbol, Any}(:alpha => 0.5), max_iter::Int64 = 100, tol::Float64 = 1e-6) --> SelfCons \nSolveMFT!(mft::TightBindingMFT{T, R}, Initial::Vector{R}, fileName::String; Update::Function = SimpleMixing, Update_kwargs::Dict{Symbol, Any} = Dict{Symbol, Any}(:alpha => 0.5), max_iter::Int64 = 100, tol::Float64 = 1e-6, checkpoint_interval::Int64 = 50) --> SelfCons\nSolveMFT!(mft::BdGMFT{T, R, R}, Initial::Vector{R}, fileName::String; Update::Function = SimpleMixing, Update_kwargs::Dict{Symbol, Any} = Dict{Symbol, Any}(:alpha => 0.5), max_iter::Int64 = 100, tol::Float64 = 1e-6, checkpoint_interval::Int64 = 50) --> SelfCons\n\nSolves the mean-field theory on the given MFT object, and returns the SelfCons object (Refer to FixedPointToolkit) containing the results of the mean-field theory.\n\nIf fileName is passed, then the SelfCons object is saved to the file after every checkpoint_interval iterations.\nIf Initial is passed, then the initial order parameters are set to the values in Initial.\nIf Initial_range is passed, then the initial order parameters are set to random values in the range Initial_range.\nIf Update is passed, then the update function is used to perform the self-consistency update.\nIf Update_kwargs is passed, then the keyword arguments are passed to the update function.\nIf max_iter is passed, then the maximum number of iterations is set to max_iter.\nIf tol is passed, then the tolerance for convergence is set to tol.\n\n\n\n\n\n","category":"method"},{"location":"InteractionConvert/#MeanFieldToolkit.InteractionConvert","page":"InteractionConvert","title":"MeanFieldToolkit.InteractionConvert","text":"","category":"section"},{"location":"InteractionConvert/","page":"InteractionConvert","title":"InteractionConvert","text":"Modules = [MeanFieldToolkit, MeanFieldToolkit.InteractionConvert]\nPrivate = false\nPages   = [\"InteractionConvert.jl\"]\n","category":"page"},{"location":"InteractionConvert/#MeanFieldToolkit.InteractionConvert.DensityToPartonCoupling-Tuple{Matrix{Float64}, Matrix{Float64}}","page":"InteractionConvert","title":"MeanFieldToolkit.InteractionConvert.DensityToPartonCoupling","text":"DensityToPartonCoupling(Ui::Matrix{Float64}, Uj::Matrix{Float64}) --> Array{ComplexF64, 4}\n\nConverts the density-density interaction matrix Ui and Uj into a parton coupling array U.\n\n\n\n\n\n","category":"method"},{"location":"InteractionConvert/#MeanFieldToolkit.InteractionConvert.SpinToPartonCoupling-Tuple{Matrix{Float64}, Rational}","page":"InteractionConvert","title":"MeanFieldToolkit.InteractionConvert.SpinToPartonCoupling","text":"SpinToPartonCoupling(J::Matrix{Float64}, spin::Rational) --> Array{ComplexF64, 4}\nSpinToPartonCoupling(J::Matrix{Float64}, SpinVec_A::Vector{Matrix{ComplexF64}}, SpinVec_B::Vector{Matrix{ComplexF64}}) --> Array{ComplexF64, 4}\n\n\nConverts the exchange matrix J into a parton coupling array U using the spin matrices SpinVec_A and SpinVec_B. If spin is passed, then the spin matrices are generated using the SpinMats function.\n\n\n\n\n\n","category":"method"},{"location":"MFTIterator/#MeanFieldToolkit.MFTIter","page":"MFTIterator","title":"MeanFieldToolkit.MFTIter","text":"","category":"section"},{"location":"MFTIterator/","page":"MFTIterator","title":"MFTIterator","text":"Modules = [MeanFieldToolkit, MeanFieldToolkit.MFTIter]\nPrivate = false\nPages   = [\"MFTIterator.jl\"]\n","category":"page"},{"location":"MFTIterator/#MeanFieldToolkit.MFTIter.DecomposeGr-Union{Tuple{R}, Tuple{T}, Tuple{Array{Matrix{ComplexF64}, T}, TightBindingToolkit.Parameters.Param{2, R}, TightBindingToolkit.UCell.UnitCell{T}, TightBindingToolkit.BZone.BZ}} where {T, R<:Union{Float64, ComplexF64}}","page":"MFTIterator","title":"MeanFieldToolkit.MFTIter.DecomposeGr","text":"DecomposeGr(Gr::Array{Matrix{ComplexF64}, T}, param::Param{2, R}, uc::UnitCell{T}, bz::BZ)\n\nDecomposes the Green's function into an order parameter.  The order parameter is calculated by taking the trace decomposition of the Green's function on each bond the order parameter exists in, and then taking the mean of all the bond order parameters, following the pattern of the given order parameter.\n\n\n\n\n\n","category":"method"},{"location":"MFTIterator/#MeanFieldToolkit.MFTIter.MFTIterator-Union{Tuple{R}, Tuple{T}, Tuple{Vector{R}, TightBindingMFT{T, R}}} where {T, R<:Union{Float64, ComplexF64}}","page":"MFTIterator","title":"MeanFieldToolkit.MFTIter.MFTIterator","text":"MFTIterator(Strengths::Vector{R}, tbMFT::TightBindingMFT{T, R}) --> Vector{R}\nMFTIterator(Strengths::Vector{R}, bdgMFT::BdGMFT{T, R, R}) --> Vector{R}\n\nRuns a single iteration of the mean-field theory on the given MFT object, and returns the new order parameters.\n\n\n\n\n\n","category":"method"},{"location":"MFTBonds/#MeanFieldToolkit.MFTBonds","page":"MFTBonds","title":"MeanFieldToolkit.MFTBonds","text":"","category":"section"},{"location":"MFTBonds/","page":"MFTBonds","title":"MFTBonds","text":"Modules = [MeanFieldToolkit, MeanFieldToolkit.MFTBonds]\nPrivate = false\nPages   = [\"MFTBonds.jl\"]\n","category":"page"},{"location":"MFTBonds/#MeanFieldToolkit.MFTBonds.GetBondCoorelation-Union{Tuple{T}, Tuple{Array{Matrix{ComplexF64}, T}, Int64, Int64, Vector{Int64}, TightBindingToolkit.UCell.UnitCell, TightBindingToolkit.BZone.BZ}} where T","page":"MFTBonds","title":"MeanFieldToolkit.MFTBonds.GetBondCoorelation","text":"GetBondCoorelation(Gr::Array{Matrix{ComplexF64}, T}, base::Int64, target::Int64, offset::Vector{Int64}, uc::UnitCell, bz::BZ) --> Matrix{ComplexF64}\nGetBondCoorelation(Gr::Array{Matrix{ComplexF64}, T}, bond::Bond, uc::UnitCell, bz::BZ) --> Matrix{ComplexF64}\n\nReturns the Greens function (correlations) on the given bond from the full Array in Gr.\n\n\n\n\n\n","category":"method"},{"location":"MFTBonds/#MeanFieldToolkit.MFTBonds.GetBondDictionary-Tuple{Dict{Tuple, Matrix{ComplexF64}}, Tuple{Int64, Int64, Vector{Int64}}, Int64}","page":"MFTBonds","title":"MeanFieldToolkit.MFTBonds.GetBondDictionary","text":"GetBondDictionary(BondLookup::Dict{Tuple, Matrix{ComplexF64}}, BondKey::Tuple{Int64, Int64, Vector{Int64}}, localDim::Int64) --> Dict{String, Matrix{ComplexF64}}\n\nGiven a lookup dictionary BondLookup, and a bond with BondKey=(i, j, offset), returns a dictionary containing the effective on-site matrices as well the bond matrices on sites i, j and bond i->j.\n\n\n\n\n\n","category":"method"},{"location":"MFTBonds/#MeanFieldToolkit.MFTBonds.GetMFTBonds-Tuple{Dict{String, Matrix{ComplexF64}}}","page":"MFTBonds","title":"MeanFieldToolkit.MFTBonds.GetMFTBonds","text":"GetMFTBonds(DecomposedBonds::Dict{String, Matrix{ComplexF64}} ; BondKey::Tuple{Int64, Int64, Vector{Int64}}, uc::UnitCell{2}, scaling::Dict{String, Float64} = Dict(\"ij\" => 1.0, \"ii\" => 1.0, \"jj\" => 1.0), labels::Dict{String, String} = Dict(\"ij\" => \"Hopping\", \"ii\" => \"Hopping On-Site\", \"jj\" => \"Hopping On-Site\"))\n\nReturns a vector of Bond objects using the bond dictionary created by [GetBondDictionary][@ref]. The bond objects have labels, and are scaled according to scaling.\n\n\n\n\n\n","category":"method"},{"location":"#MeanFieldToolkit.jl","page":"Introduction","title":"MeanFieldToolkit.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"MeanFieldToolkit.jl is a Julia package meant for solving generalized self-consistent mean-field equations on a lattice.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently supported :","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Lattice implementation is done through TightBindingToolkit.jl. Any custom lattice in d=1,2,3 is supported.\nUser can input any two-site interaction in the form of arrays, and their corresponding mean-field equations. Simple four-fermion interactions are already built in (such as Hubbard, Spin-Spin interactions etc.).\nCan track any hopping and pairing order parameters.\nSelf-consistentcy solver is implemented using FixedPointToolkit.jl. Can customize the solver, the tolerance of convergence, the maximum number of iterations and so on.\nCan checkpoint and save results into JLD2 files, and resume iterations from reading such files.\nCan plot results of order parameters, and the mean-field ground state energy as a function of iterations.","category":"page"}]
}
